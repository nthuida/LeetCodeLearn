#### 岛屿问题
1、深度优先遍历  
2、用不同的值，标记已访问  
3、四个方向遍历  
````
    void dfs(int[][] grid, int r, int c) {
        // 判断 base case
        if (!inArea(grid, r, c)) {
            return;
        }
        // 如果这个格子不是岛屿，直接返回
        if (grid[r][c] != 1) {
            return;
        }
        // 将格子标记为「已遍历过」
        grid[r][c] = 2;
        // 访问上、下、左、右四个相邻结点
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }
````
1.岛屿的数量

2.岛屿的最大面积  
每次遍历一个岛屿的时候，在dfs中对面积计数，比较最大值

3.统计封闭岛屿的数目  
先去除边界的岛屿，再对剩下的岛屿计数  

4.飞地的数量  
先去除边界的岛屿，再对剩下的岛屿，dfs中统计其飞地

5.岛屿的周长  
1、岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量  
2、从岛屿走向网格边界时计数+1、从岛屿走向水域计数+1  

6.统计子岛屿  
1、排除不在A中的岛屿
````
if (grid1[i][j] == 0 && grid2[i][j] == 1) {
    dfs(grid2, i, j);
}
````
2、统计B中剩余岛屿数量

7.被围绕的区域  
1、从反向入手，先确定不被围绕的区域，剩余的区域都是被围绕的  
2、边界'O'以及和他相连的'O'不被围绕，先标记为出来  
3、最后遍历，重新标记