#### 解题步骤  
1、定义状态 2、确定状态转移方程 3、数组初始化 4、确定遍历顺序：根据最终求的值   
#### 背包问题  
1.01背包  
  分割等和子集、目标和  
2.完全背包  
  零钱兑换、零钱兑换II、完全平方数、单词拆分、组合总和IV
#### 打家劫舍  
  1、相邻的不同时偷 2、首尾围成一圈，相邻不偷且头和尾不同时偷 3、树结构相连，根节点和子节点不同时偷  
#### 股票系列  
1.只买卖一次  
第i天不持有可获得的最大利润：dp[i][1] = max(dp[i - 1][1], -prices[i])  
表示第i天持有可获得的最大利润：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  

2.买卖多次  
dp[i][1] = max(dp[i - 1][1], dp[i-1][0] - prices[i])  
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  

3.最多买卖两次  
dp[i][j][k]代表 第i天交易了k次时的最大利润，其中j代表当天是否持有股票，0不持有，1持有  
dp[i][0][j] = max(dp[i-1][0][j], dp[i-1][1][j] + prices[i])  
dp[i][1][j] = max(dp[i-1][1][j], dp[i-1][0][j-1] - prices[i])  

4.最多买卖K次  
同3  

5.最佳买卖股票时机含冷冻期(买卖多次，卖出后有一天冷冻期)  
dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])  
持有：前一天持有或者前一天不持有，不处于冷冻期，今天买入  
dp[i][1] = max(dp[i-1][2], dp[i-1][1])  
不持有，不在冷冻期：前一天卖出，冷冻期或者前一天也是非冷冻  
dp[i][2] = dp[i-1][0] + prices[i]  
不持有，在冷冻期: 前一天持有，今天卖出  

6.买卖股票的最佳时机含手续费(买卖多次，每次有手续费)  
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)  
不持有：1. 昨天也不持有；2. 昨天持有，今天卖出  
dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])  
持有：1. 昨天也持有；2. 昨天不持有，今天买入  

#### 子数组问题  
1.最长重复子数组  
dp[i][j] = 0,                A[i]!=B[j]  
dp[i][j] = dp[i-1][j-1] + 1, A[i]==B[j]  

2.最长连续递增序列  
dp[i] = dp[i-1] + 1  

3.乘积最大子数组  
dpMax[i] = max(max(dpMax[i-1] * nums[i], nums[i]), dpMin[i-1] * nums[i])  
dpMin[i] = min(min(dpMin[i-1] * nums[i], nums[i]), dpMax[i-1] * nums[i])  
因为有正负，最大值可以由最小值乘以负数得到，同样最小值可以由最大值乘以负数得到  

4.最大子序和  
dp[i] = max(dp[i-1] + nums[i], nums[i])  

#### 子序列问题  
1.最长递增子序列  
dp[i] = max(dp[i], dp[j] + 1)   0<=j<i

2.最长递增子序列的个数  
  定义两个动态数组：dp[i]以i结尾的最长子序列长度；count[i]以i结尾的最长子序列个数  

3.最长公共子序列  
dp[i][j] = dp[i−1][j−1]+1,              text1[i-1] == text2[j-1]  
dp[i][j] = max(dp[i−1][j], dp[i][j−1]), text1[i-1] != text2[j-1]  

4.最长回文子序列  
从下往上，从左往右，对角线遍历  
dp[i][j] = dp[i+1][j-1] + 2             s[i] == s[j]  
dp[i][j] = max(dp[i+1][j], dp[i][j-1])  s[i] != s[j]  

5.俄罗斯套娃信封问题  
  1、所有的信封按照w值第一关键字升序、h值第二关键字降序进行排序  
  2、忽略w维度，转化为求h维度的最长递增子序列  

6.两个字符串的最小ASCII删除和  
转化为求两个字符串的最大公共子序列，并且使其ASCII编码最大  

7.不同的子序列  
dp[i][j]表示以s[i]、t[j]结尾的不同子序列的个数  
dp[i][j] = dp[i-1][j-1] + dp[i-1][j]  s[i] == t[j]  
相等时，分为两种情况：用s[i]这个元素区去配,个数为dp[i-1][j-1], 不用s[i]这个元素去匹配，个数为dp[i-1][j]  
dp[i][j] = dp[i-1][j]                 s[i] != t[j]  

#### 字符串问题
1.交错字符串  
dp[i][j]表示s1的前i个字符和s2的前j个字符是否可以构成s3的前i+j个字符  
dp[i][j] = dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)  
         || dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1)  

2.编辑距离  
dp[i][j]表示以word1[i],word2[j]结尾转换所使用的最小操作数  
dp[i-1][j-1]表示替换，dp[i-1][j]表示删除，dp[i][j-1]表示添加  
dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1  word1[i] != word2[j]
dp[i][j] = dp[i-1][j-1]                                 word1[i] == word2[j]  

3.两个字符串的删除操作  
dp[i][j]表示以word1[i],word2[j]结尾的字符相同所需的最小步数  
dp[i][j] = dp[i-1][j-1]                     word1[i] == word2[j]   
dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1  word1[i] != word2[j]  

4.让字符串成为回文串的最少插入次数  
从下往上，从左往右，对角线遍历  
dp[i][j] 表示子串s[i:j]变为回文串的最小插入次数  
dp[i][j] = dp[i+1][j-1]                    s[i] == s[j]  
dp[i][j] = min(dp[i+1][j], dp[i][j-1]) +1  s[i] != s[j]  

5.通配符匹配  
dp[i][j]表示s的前i个字符和p的前j个字符是否匹配  
dp[i][j] = dp[i - 1][j - 1]                s[i] == p[j] || p[j] == ?  
dp[i][j] = dp[i][j - 1] || dp[i - 1][j]    p[j] == *  

6.正则表达式匹配  
dp[i][j]表示s的前i个字符和p的前j个字符是否匹配  
dp[i][j] = dp[i-1][j-1]                            p[j] == s[i] || p[j] = '.'  
dp[i][j] = dp[i][j-2]                              p[j-1] != s[i]  
dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i][j-2]  p[j-1] == s[i] or p[j-1] == '.'  
注意：'*' 匹配零个等于删除，区别与通配符匹配  

#### 路径问题  
1.下降路径最小和  
dp[i][j]表示i行j列的最小路径和  
dp[i][j] = min(Math.min(dp[i-1][j-1],dp[i-1][j]),dp[i-1][j+1]) + matrix[i][j]  

2.三角形最小路径和  
同1  

3.最小路径和  
dp[i][j] = min(dp[i][j-1] + grid[i][j], dp[i-1][j] + grid[i][j])  

4.不同路径  
dp[i][j] = dp[i-1][j] + dp[i][j-1]  

5.最大正方形  
dp[i][j]表示以 (i, j)为右下角，且只包含 1的正方形的边长最大值   
dp[i][j] = min(dp[i−1][j], dp[i−1][j−1], dp[i][j−1])+1  

#### 解码问题  
1.解码方法  
dp[i]表示以i结尾的字符串的解码总数  
dp[i] = dp[i-1]  1<=a<=9 以一个字符i解码  
dp[i] = dp[i-1] + dp[i-2] 10<=b<=26 以两个字符[i-1,i]解码  
注意：0不能单独翻译，必须和前面组成两个字符，区别与"把数字翻译成字符串"  

2.把数字翻译成字符串  
dp[i]表示以i为结尾的数字的翻译方案数量
dp[i] = dp[i - 1] + dp[i - 2]，i-1和i组成的两位数字可以被翻译  
dp[i] = dp[i - 1]  

#### 地下城游戏  
从下往上，从右往左遍历  
dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) − dungeon(i,j), 1)  
#### 戳气球  
dp[i][j]表示戳破气球i和气球j之间（不包括i和j）的所有气球，可以获得的分数  
dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[i]*points[k]*points[j]) i<k<j，k为最后一个戳破的气球  
#### 使用最小花费爬楼梯  
dp[i]表示到达第i个台阶的最低花费  
dp[i] = min(dp[i-1], d[i-2]) + cost[i]  
#### 整数拆分
dp[i] = max((i-j)*j, j*dp[i-j]), i<=j<i  
#### 最低票价  
dp[i] 表示第i天为止，所需的最小费用  
dp[i] = min(c[0] + dp[i-1], c[1] + dp[i-7], c[2] + dp[i-30])  
#### 预测赢家  
dp[i][j]表示在子数组[i,j]中，玩家1对玩家2的净胜分  
dp[i][j] = max(nums[i]-dp[i+1][j], nums[j]-dp[i][j-1])  
#### 鸡蛋掉落  
dp[k][n] 表示k个鸡蛋，扔n次，最多可以测试的楼层数  
dp[k][n] = dp[k][n-1] + dp[k-1][n-1] + 1  



